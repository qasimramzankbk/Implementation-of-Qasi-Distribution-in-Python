# Install required packages (run once in Kaggle notebook)
# !pip install plotly numpy scipy

import numpy as np
import plotly.graph_objects as go
from plotly.offline import iplot
import itertools
from scipy.integrate import quad, IntegrationWarning
import warnings

# Ignore integration warnings
warnings.filterwarnings("ignore", category=IntegrationWarning)
epsilon = 1e-10

# Define gamma_* functions as provided
def gamma_pdf(gamma_param, theta, lambd, x):
    term1 = 1 + 2 * theta * x
    term2 = np.exp(-2 * theta * x)
    numerator = gamma_param * (theta ** 2) * x * term2
    inner_term = 1 - term1 * term2
    numerator_exp = (inner_term ** lambd)
    denominator_exp = (1 - inner_term ** lambd) ** 2
    exp_term = np.exp(-gamma_param * numerator_exp / (1 - inner_term ** lambd))
    result = numerator * (numerator_exp / denominator_exp) * exp_term
    return np.where(x >= 0, result, 0)

def gamma_hf(gamma_param, theta, lambd, x, epsilon=1e-10):
    term1 = 1 + 2 * theta * x
    term2 = np.exp(-2 * theta * x)
    numerator = gamma_param * (theta ** 2) * x * term2
    inner_term = 1 - term1 * term2
    numerator_exp = (inner_term ** lambd)
    denominator_exp = (1 - inner_term ** lambd) ** 2
    result = numerator * (numerator_exp / (denominator_exp + epsilon))
    return result

def gamma_sf(gamma_param, theta, lambd, x):
    term1 = 1 + 2 * theta * x
    term2 = np.exp(-2 * theta * x)
    numerator = gamma_param * (theta ** 2) * x * term2
    inner_term = 1 - term1 * term2
    numerator_exp = (inner_term ** lambd)
    denominator_exp = (1 - inner_term ** lambd) ** 2
    result = np.exp(-gamma_param * numerator_exp / (1 - inner_term ** lambd))
    return np.maximum(result, epsilon)

def gamma_rhrf(gamma_param, theta, lambd, x, epsilon=1e-10, max_exp=1e50):
    term1 = 1 + 2 * theta * x
    term2 = np.exp(-2 * theta * x)
    numerator = gamma_param * (theta ** 2) * x * term2
    inner_term = 1 - term1 * term2
    numerator_exp = (inner_term ** lambd)
    denominator_exp = (1 - inner_term ** lambd) ** 2
    ex_term = np.clip(np.exp(gamma_param * numerator_exp / (1 - inner_term ** lambd + epsilon)), -max_exp, max_exp)
    result = numerator * (numerator_exp / (denominator_exp + epsilon)) / (ex_term - 1 + epsilon)
    return result

def gamma_chf(gamma_param, theta, lambd, x):
    term1 = 1 + 2 * theta * x
    term2 = np.exp(-2 * theta * x)
    inner_term = 1 - term1 * term2
    numerator_exp = (inner_term ** lambd)
    result = gamma_param * numerator_exp / (1 - inner_term ** lambd + epsilon)
    return result

def integrand_m(u, gamma_param, theta, lambd):
    term1 = 1 + 2 * theta * u
    term2 = np.exp(-2 * theta * u)
    inner_term = 1 - term1 * term2
    numerator_exp = inner_term ** lambd
    denominator_exp = (1 - numerator_exp) ** 2
    exp_term = np.exp(-gamma_param * numerator_exp / (1 - numerator_exp + epsilon))
    result = u ** 2 * term2 * numerator_exp / (denominator_exp + epsilon) * exp_term
    return result

def m_function(x, gamma_param, theta, lambd):
    term1 = 1 + 2 * theta * x
    term2 = np.exp(-2 * theta * x)
    inner_term = 1 - term1 * term2
    numerator_exp = inner_term ** lambd
    exp_term = np.exp(-gamma_param * numerator_exp / (1 - numerator_exp + epsilon))
    prefactor = gamma_param * (theta ** 2) / (exp_term + epsilon)
    integral, _ = quad(integrand_m, x, np.inf, args=(gamma_param, theta, lambd), limit=100)
    result = prefactor * integral - x
    return np.where(np.isfinite(result), result, np.inf)

def integrand_w(u, gamma_param, theta, lambd):
    term1 = 1 + 2 * theta * u
    term2 = np.exp(-2 * theta * u)
    inner_term = 1 - term1 * term2
    numerator_exp = inner_term ** lambd
    denominator_exp = (1 - numerator_exp) ** 2
    exp_term = np.exp(-gamma_param * numerator_exp / (1 - numerator_exp + epsilon))
    result = u ** 2 * term2 * numerator_exp / (denominator_exp + epsilon) * exp_term
    return result

def w_function(x, gamma_param, theta, lambd):
    term1 = 1 + 2 * theta * x
    term2 = np.exp(-2 * theta * x)
    inner_term = 1 - term1 * term2
    numerator_exp = inner_term ** lambd
    exp_term = np.exp(-gamma_param * numerator_exp / (1 - numerator_exp + epsilon))
    prefactor = gamma_param * (theta ** 2) / (1 - exp_term + epsilon)
    integral, _ = quad(integrand_w, 0, x, args=(gamma_param, theta, lambd), limit=100)
    result = x - prefactor * integral
    return np.where(np.isfinite(result), result, 0)

# Sample data (Aircraft Windshield failure times)
data = np.array([0.040, 1.866, 2.385, 3.443, 0.301, 1.876, 2.481, 3.467, 0.309,
                 1.899, 2.610, 3.478, 0.557, 1.911, 2.625, 3.578, 0.943, 1.912,
                 2.632, 3.595, 1.070, 1.914, 2.646, 3.699, 1.124, 1.981, 2.661,
                 3.779, 1.248, 2.010, 2.688, 3.924, 1.281, 2.038, 2.823, 4.035,
                 1.281, 2.085, 2.890, 4.121, 1.303, 2.089, 2.902, 4.167, 1.432,
                 2.097, 2.934, 4.240, 1.480, 2.135, 2.962, 4.255, 1.505, 2.154,
                 2.964, 4.278, 1.506, 2.190, 3.000, 4.305, 1.568, 2.194, 3.103,
                 4.376, 1.615, 2.223, 3.114, 4.449, 1.619, 2.224, 3.117, 4.485,
                 1.652, 2.229, 3.166, 4.570, 1.652, 2.300, 3.344, 4.602, 1.757,
                 2.324, 3.376, 4.663])

# Evaluate functions
results = {
    'pdf': gamma_pdf(0.2, 0.03, 0.05, data),
    'sf': gamma_sf(0.2, 0.03, 0.05, data),
    'hf': gamma_hf(0.2, 0.03, 0.05, data),
    'rhrf': gamma_rhrf(0.2, 0.03, 0.05, data),
    'chf': gamma_chf(0.2, 0.03, 0.05, data),
    'm': np.array([m_function(x, 0.8, 1.3, 0.5) for x in data]),
    'w': np.array([w_function(x, 0.2, 0.03, 0.05) for x in data])
}

# 3D Surface Plots for all combinations
variables = {
    'pdf': results['pdf'],
    'sf': results['sf'],
    'hf': results['hf'],
    'rhrf': results['rhrf'],
    'chf': results['chf'],
    'm': results['m'],
    'w': results['w']
}

combinations = list(itertools.combinations(variables.keys(), 3))

for combo in combinations:
    x_var, y_var, z_var = combo
    x = variables[x_var]
    y = variables[y_var]
    z = variables[z_var]

    # Ensure consistent lengths and create meshgrid
    min_len = min(len(x), len(y), len(z))
    x = x[:min_len]
    y = y[:min_len]
    z = z[:min_len]
    y, z = np.meshgrid(y, z)
    x = np.tile(x, (len(y), 1))  # Expand x to match meshgrid

    fig = go.Figure(data=[go.Surface(x=x, y=y, z=z)])
    fig.update_layout(
        title=f'3D Surface Plot of {x_var}, {y_var}, and {z_var}',
        scene=dict(xaxis_title=x_var, yaxis_title=y_var, zaxis_title=z_var)
    )
    iplot(fig)  # Use iplot for Kaggle compatibility
